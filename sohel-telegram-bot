import sys
import pytz
import random
import asyncio
from datetime import datetime, timedelta
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import Application, CommandHandler, CallbackQueryHandler, ContextTypes
import logging
import json

# ==================== CONFIGURATION ====================
import os
TOKEN = os.getenv("BOT_TOKEN")

ADMIN_ID = 8516585362
BD_TZ = pytz.timezone('Asia/Dhaka')

# à¦²à¦—à¦¿à¦‚ à¦¸à§‡à¦Ÿà¦†à¦ª
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)
logger = logging.getLogger(__name__)

# ==================== MARKET DATA ====================
MARKET_DATA = {
    "OTC": {
        "AUD/NZD": {"accuracy": 88, "payout": "96%", "emoji": "ðŸ‡¦ðŸ‡ºðŸ‡³ðŸ‡¿"},
        "USD/INR": {"accuracy": 86, "payout": "94%", "emoji": "ðŸ‡ºðŸ‡¸ðŸ‡®ðŸ‡³"},
        "USD/BRL": {"accuracy": 84, "payout": "95%", "emoji": "ðŸ‡ºðŸ‡¸ðŸ‡§ðŸ‡·"},
        "USD/ARS": {"accuracy": 90, "payout": "97%", "emoji": "ðŸ‡ºðŸ‡¸ðŸ‡¦ðŸ‡·"},
        "USD/BDT": {"accuracy": 87, "payout": "93%", "emoji": "ðŸ‡ºðŸ‡¸ðŸ‡§ðŸ‡©"},
        "USD/PKR": {"accuracy": 85, "payout": "94%", "emoji": "ðŸ‡ºðŸ‡¸ðŸ‡µðŸ‡°"},
        "USD/TRY": {"accuracy": 83, "payout": "96%", "emoji": "ðŸ‡ºðŸ‡¸ðŸ‡¹ðŸ‡·"},
        "EUR/TRY": {"accuracy": 82, "payout": "95%", "emoji": "ðŸ‡ªðŸ‡ºðŸ‡¹ðŸ‡·"},
    },
    "FOREX": {
        "EUR/USD": {"accuracy": 78, "payout": "91%", "emoji": "ðŸ‡ªðŸ‡ºðŸ‡ºðŸ‡¸"},
        "GBP/USD": {"accuracy": 76, "payout": "92%", "emoji": "ðŸ‡¬ðŸ‡§ðŸ‡ºðŸ‡¸"},
        "USD/JPY": {"accuracy": 82, "payout": "93%", "emoji": "ðŸ‡ºðŸ‡¸ðŸ‡¯ðŸ‡µ"},
        "AUD/USD": {"accuracy": 75, "payout": "90%", "emoji": "ðŸ‡¦ðŸ‡ºðŸ‡ºðŸ‡¸"},
        "EUR/GBP": {"accuracy": 77, "payout": "92%", "emoji": "ðŸ‡ªðŸ‡ºðŸ‡¬ðŸ‡§"},
        "GBP/JPY": {"accuracy": 74, "payout": "94%", "emoji": "ðŸ‡¬ðŸ‡§ðŸ‡¯ðŸ‡µ"},
    },
    "CRYPTO": {
        "BTC/USD": {"accuracy": 72, "payout": "98%", "emoji": "â‚¿"},
        "ETH/USD": {"accuracy": 70, "payout": "96%", "emoji": "Îž"},
        "XRP/USD": {"accuracy": 68, "payout": "95%", "emoji": "âœ•"},
        "ADA/USD": {"accuracy": 65, "payout": "97%", "emoji": "ðŸ…°"},
    },
    "COMMODITIES": {
        "GOLD": {"accuracy": 84, "payout": "92%", "emoji": "ðŸ¥‡"},
        "SILVER": {"accuracy": 80, "payout": "93%", "emoji": "ðŸ¥ˆ"},
        "OIL": {"accuracy": 76, "payout": "91%", "emoji": "ðŸ›¢"},
    }
}

# ==================== HELPER FUNCTIONS ====================
def get_bd_time():
    return datetime.now(BD_TZ)

def format_time(dt):
    return dt.strftime("%H:%M:%S")

def get_next_candle_time():
    now = get_bd_time()
    next_min = (now.minute + 1) % 60
    next_hr = now.hour if now.minute < 59 else (now.hour + 1) % 24
    return f"{next_hr:02d}:{next_min:02d}"

def get_market_emoji(pair):
    for category in MARKET_DATA.values():
        if pair in category:
            return category[pair]["emoji"]
    return "ðŸ“Š"

# ==================== SIGNAL GENERATOR ====================
class SignalGenerator:
    def __init__(self):
        self.history = []
    
    def generate(self, market_type=None):
        if market_type and market_type in MARKET_DATA:
            pairs = list(MARKET_DATA[market_type].keys())
            pair = random.choice(pairs)
            info = MARKET_DATA[market_type][pair]
        else:
            all_pairs = []
            all_info = []
            for cat, data in MARKET_DATA.items():
                for p, info in data.items():
                    all_pairs.append(p)
                    all_info.append((info, cat))
            
            idx = random.randint(0, len(all_pairs)-1)
            pair = all_pairs[idx]
            info, market_type = all_info[idx]
        
        # Direction based on accuracy
        direction = "UP" if random.random() * 100 < info["accuracy"] else "DOWN"
        timeframe = random.choice([1, 2, 3, 5])
        
        current = get_bd_time()
        expiry = current + timedelta(minutes=timeframe)
        
        signal = {
            "id": len(self.history) + 1,
            "pair": pair,
            "market": market_type,
            "direction": direction,
            "timeframe": f"{timeframe}M",
            "entry_time": format_time(current),
            "expiry_time": format_time(expiry),
            "accuracy": f"{info['accuracy']}%",
            "payout": info["payout"],
            "emoji": info["emoji"],
            "timestamp": current.timestamp()
        }
        
        self.history.append(signal)
        return signal

# ==================== BOT CLASS ====================
class FinorixStyleBot:
    def __init__(self):
        self.app = None
        self.signal_gen = SignalGenerator()
        self.user_data = {}
    
    async def start(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        user = update.effective_user
        
        keyboard = [
            [
                InlineKeyboardButton("ðŸ“¡ GET SIGNAL", callback_data="signal"),
                InlineKeyboardButton("ðŸ“Š STATS", callback_data="stats")
            ],
            [
                InlineKeyboardButton("ðŸ’Ž OTC", callback_data="market_otc"),
                InlineKeyboardButton("ðŸŒ FOREX", callback_data="market_forex"),
                InlineKeyboardButton("ðŸš€ CRYPTO", callback_data="market_crypto")
            ],
            [
                InlineKeyboardButton("âš™ï¸ SETTINGS", callback_data="settings"),
                InlineKeyboardButton("ðŸ’° VIP", callback_data="vip"),
                InlineKeyboardButton("â“ HELP", callback_data="help")
            ]
        ]
        
        welcome = f"""
ðŸŒŸ *WELCOME TO QUOTEX SIGNALS* ðŸŒŸ

ðŸ‘‹ Hello *{user.first_name}*!

ðŸ¤– *BOT FEATURES:*
âœ… 30+ Markets Covered
âœ… High Accuracy Signals
âœ… Real-time Analysis
âœ… Bangladesh Time (UTC+6)
âœ… Auto Signal Generation

ðŸ“ˆ *PERFORMANCE:*
ðŸ† Win Rate: *84.5%*
ðŸ“Š Total Signals: *127*
ðŸŽ¯ Avg. Accuracy: *82.3%*
ðŸ’° Avg. Payout: *94.2%*

ðŸ• *Bangladesh Time:* {get_bd_time().strftime('%H:%M:%S')}
â° *Next Candle:* {get_next_candle_time()}

âš ï¸ *Risk Warning:* Trading involves high risk.
"""
        
        await update.message.reply_text(
            welcome,
            parse_mode='Markdown',
            reply_markup=InlineKeyboardMarkup(keyboard)
        )
    
    async def send_signal(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        loading_msg = await update.message.reply_text(
            "ðŸ”„ *Analyzing Markets...*\n"
            "ðŸ“Š Scanning 30+ pairs...\n"
            "ðŸŽ¯ Calculating best entry point...",
            parse_mode='Markdown'
        )
        
        await asyncio.sleep(2)
        
        signal = self.signal_gen.generate()
        emoji = get_market_emoji(signal["pair"])
        
        signal_text = f"""
{signal['emoji']} *{signal['pair']}* {signal['emoji']}
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ðŸ• *Time:* {signal['entry_time']} (UTC+6)
â° *Next Candle:* {get_next_candle_time()}
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

ðŸŽ¯ *SIGNAL DETAILS:*
ðŸ“Š Market: {signal['market']}
ðŸ“ˆ Direction: {'ðŸŸ¢ *BUY (UP)*' if signal['direction'] == 'UP' else 'ðŸ”´ *SELL (DOWN)*'}
â± Timeframe: {signal['timeframe']}
ðŸ“‰ Expiry: {signal['expiry_time']}
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

ðŸ“Š *PERFORMANCE METRICS:*
âœ… Accuracy: {signal['accuracy']}
ðŸ’° Payout: {signal['payout']}
ðŸ“ˆ Trend: {random.choice(['â†—ï¸ Bullish', 'â†˜ï¸ Bearish', 'âž¡ï¸ Sideways'])}
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

ðŸ’¡ *TRADING TIPS:*
â€¢ Entry at candle open
â€¢ Use 1-5% risk per trade
â€¢ Set Stop Loss always
â€¢ Trade with confirmation
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

âš ï¸ *DISCLAIMER:*
This is not financial advice.
Trade at your own risk.
Past performance â‰  future results.
"""
        
        keyboard = [
            [
                InlineKeyboardButton("âœ… WIN", callback_data=f"win_{signal['id']}"),
                InlineKeyboardButton("âŒ LOSS", callback_data=f"loss_{signal['id']}")
            ],
            [
                InlineKeyboardButton("ðŸ”„ NEW SIGNAL", callback_data="signal"),
                InlineKeyboardButton("ðŸ“Š STATS", callback_data="stats")
            ]
        ]
        
        try:
            await context.bot.delete_message(
                chat_id=update.effective_chat.id,
                message_id=loading_msg.message_id
            )
        except:
            pass
        
        await update.message.reply_text(
            signal_text,
            parse_mode='Markdown',
            reply_markup=InlineKeyboardMarkup(keyboard)
        )
    
    async def stats_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        stats_text = f"""
ðŸ“Š *BOT STATISTICS* ðŸ“Š
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ðŸ“… *Date:* {get_bd_time().strftime('%d %B %Y')}
ðŸ• *Time:* {format_time(get_bd_time())}
â° *Next Candle:* {get_next_candle_time()}
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

ðŸ“ˆ *OVERALL PERFORMANCE:*
ðŸ† Win Rate: *84.5%*
ðŸ“Š Total Signals: *1,274*
ðŸŽ¯ Avg. Accuracy: *82.3%*
ðŸ’° Avg. Payout: *94.2%*
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

ðŸ“Š *DAILY STATS (TODAY):*
âœ… Signals: 12
ðŸŽ¯ Wins: 10
ðŸ“‰ Losses: 2
ðŸ“Š Accuracy: *83.3%*
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

ðŸ”¥ *TOP 3 PAIRS:*
ðŸ¥‡ USD/ARS - 90% Accuracy
ðŸ¥ˆ AUD/NZD - 88% Accuracy
ðŸ¥‰ USD/BDT - 87% Accuracy
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

ðŸ”„ Last updated: Just now
"""
        
        keyboard = [[InlineKeyboardButton("ðŸ”„ REFRESH", callback_data="stats")]]
        
        await update.message.reply_text(
            stats_text,
            parse_mode='Markdown',
            reply_markup=InlineKeyboardMarkup(keyboard)
        )
    
    async def time_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        bd_time = get_bd_time()
        time_text = f"""
ðŸ• *TIME INFORMATION* ðŸ•
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ðŸ“ *Bangladesh Time (UTC+6):*
ðŸ“… Date: {bd_time.strftime('%A, %d %B %Y')}
ðŸ• Time: {format_time(bd_time)}
â° Next Candle: {get_next_candle_time()}
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

ðŸŒ *WORLD TRADING SESSIONS:*
ðŸ‡§ðŸ‡© *Dhaka (Open):* {format_time(bd_time)}
ðŸ‡¸ðŸ‡¬ *Singapore:* {format_time(bd_time + timedelta(hours=2))}
ðŸ‡¯ðŸ‡µ *Tokyo:* {format_time(bd_time + timedelta(hours=3))}
ðŸ‡¬ðŸ‡§ *London:* {format_time(bd_time - timedelta(hours=6))}
ðŸ‡ºðŸ‡¸ *New York:* {format_time(bd_time - timedelta(hours=11))}
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

â° *TRADING HOURS:*
â€¢ OTC: 24/7
â€¢ Forex: 24/5
â€¢ Crypto: 24/7
â€¢ Commodities: 24/5
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
"""
        
        await update.message.reply_text(time_text, parse_mode='Markdown')
    
    async def help_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        help_text = """
ðŸ†˜ *HELP & COMMANDS* ðŸ†˜
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
*ðŸ“¡ SIGNAL COMMANDS:*
/signal - Get trading signal
/otc - OTC market signals
/forex - Forex market signals
/crypto - Crypto market signals

*ðŸ“Š INFO COMMANDS:*
/stats - Bot performance statistics
/time - Current time information
/top - Top performing pairs
/markets - All available markets

*âš™ï¸ SETTINGS:*
Use inline buttons for quick access
Click WIN/LOSS to improve accuracy
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
*ðŸ“ž SUPPORT:*
For assistance, contact admin
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
*âš ï¸ DISCLAIMER:*
This bot provides educational signals.
We are not financial advisors.
Trade responsibly.
"""
        
        await update.message.reply_text(help_text, parse_mode='Markdown')
    
    async def callback_handler(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        query = update.callback_query
        await query.answer()
        
        data = query.data
        
        if data == "signal":
            await self.send_signal_callback(query, context)
        elif data == "stats":
            await self.stats_callback(query, context)
        elif data == "time":
            await self.time_callback(query, context)
        elif data == "help":
            await self.help_callback(query, context)
        elif data.startswith("market_"):
            market = data.split("_")[1].upper()
            await query.edit_message_text(
                f"âœ… *Market set to: {market}*\n\nNow use /signal to get {market} signals.",
                parse_mode='Markdown'
            )
        elif data.startswith("win_") or data.startswith("loss_"):
            await query.edit_message_text(
                "âœ… *Thank you for your feedback!*\n\nYour response helps improve our algorithm.",
                parse_mode='Markdown'
            )
        elif data == "settings":
            await query.edit_message_text(
                "âš™ï¸ *SETTINGS*\n\nâ€¢ Default Market: All\nâ€¢ Timezone: UTC+6\nâ€¢ Notifications: On\nâ€¢ Auto-refresh: Enabled",
                parse_mode='Markdown'
            )
        elif data == "vip":
            await query.edit_message_text(
                "ðŸ’° *VIP ACCESS*\n\nPremium features include:\nâ€¢ Priority signals\nâ€¢ Early access\nâ€¢ Higher accuracy\nâ€¢ Personal support\n\nContact admin for VIP access.",
                parse_mode='Markdown'
            )
    
    async def send_signal_callback(self, query, context):
        signal = self.signal_gen.generate()
        
        signal_text = f"""
ðŸš€ *QUOTEX SIGNAL*
â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ðŸ“Š Pair: `{signal['pair']}`
ðŸŽ¯ Direction: {signal['direction']}
â± Timeframe: {signal['timeframe']}
âœ… Accuracy: {signal['accuracy']}
"""
        
        keyboard = [
            [
                InlineKeyboardButton("âœ… WIN", callback_data=f"win_{signal['id']}"),
                InlineKeyboardButton("âŒ LOSS", callback_data=f"loss_{signal['id']}")
            ]
        ]
        
        await query.edit_message_text(
            signal_text,
            parse_mode='Markdown',
            reply_markup=InlineKeyboardMarkup(keyboard)
        )
    
    async def stats_callback(self, query, context):
        stats_text = f"""
ðŸ“Š *STATISTICS*
â”â”â”â”â”â”â”â”â”â”â”â”
ðŸ• Time: {format_time(get_bd_time())}
â° Next: {get_next_candle_time()}
ðŸ“ˆ Win Rate: 84.5%
ðŸŽ¯ Accuracy: 82.3%
"""
        
        keyboard = [[InlineKeyboardButton("ðŸ”„ REFRESH", callback_data="stats")]]
        
        await query.edit_message_text(
            stats_text,
            parse_mode='Markdown',
            reply_markup=InlineKeyboardMarkup(keyboard)
        )
    
    async def time_callback(self, query, context):
        bd_time = get_bd_time()
        time_text = f"""
ðŸ• *TIME*
â”â”â”â”â”â”â”â”â”â”â”â”
ðŸ“ Bangladesh: {format_time(bd_time)}
â° Next Candle: {get_next_candle_time()}
ðŸ‡¬ðŸ‡§ London: {format_time(bd_time - timedelta(hours=6))}
ðŸ‡ºðŸ‡¸ New York: {format_time(bd_time - timedelta(hours=11))}
"""
        
        await query.edit_message_text(time_text, parse_mode='Markdown')
    
    async def help_callback(self, query, context):
        help_text = """
ðŸ†˜ *HELP*
â”â”â”â”â”â”â”â”â”â”â”â”
ðŸ“¡ /signal - Get signal
ðŸ“Š /stats - View stats
ðŸ• /time - Check time
â“ /help - This message
â”â”â”â”â”â”â”â”â”â”â”â”
Use buttons for quick access
"""
        
        await query.edit_message_text(help_text, parse_mode='Markdown')
    
    def run(self):
        """Start the bot"""
        print("=" * 80)
        print("ðŸ¤– FINORIX-STYLE QUOTEX BOT")
        print(f"ðŸ”— Token: {TOKEN[:15]}...")
        print(f"ðŸŒ Timezone: UTC+6 (Bangladesh)")
        print("ðŸ“Š Markets: OTC, Forex, Crypto, Commodities")
        print("ðŸŽ¯ Features: Professional Signals, Stats, Inline Buttons")
        print("=" * 80)
        
        self.app = Application.builder().token(TOKEN).build()
        
        # Add handlers
        self.app.add_handler(CommandHandler("start", self.start))
        self.app.add_handler(CommandHandler("signal", self.send_signal))
        self.app.add_handler(CommandHandler("stats", self.stats_command))
        self.app.add_handler(CommandHandler("time", self.time_command))
        self.app.add_handler(CommandHandler("help", self.help_command))
        self.app.add_handler(CommandHandler("otc", lambda u, c: self.send_signal(u, c)))
        self.app.add_handler(CommandHandler("forex", lambda u, c: self.send_signal(u, c)))
        self.app.add_handler(CommandHandler("crypto", lambda u, c: self.send_signal(u, c)))
        
        # Callback handler
        self.app.add_handler(CallbackQueryHandler(self.callback_handler))
        
        print("âœ… Bot is running...")
        print("ðŸ“± Telegram: Use /start command")
        print("ðŸ›‘ Press Ctrl+C to stop")
        print("=" * 80)
        
        self.app.run_polling(allowed_updates=Update.ALL_TYPES)

# ==================== MAIN ====================
def main():
    try:
        bot = FinorixStyleBot()
        bot.run()
    except Exception as e:
        logger.error(f"Error: {e}")
        sys.exit(1)

if __name__ == "__main__":
    main()

